# -*- coding: utf-8 -*-
"""Bot v6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19O3CQM4O3o6V5n8TFrSTrTZLCUKNBVGu
"""

!pip install discord.py
!pip install nest_asyncio 
!pip install schedule

import nest_asyncio 
nest_asyncio.apply()

"""Axe d'amélioration :
Pour l'instant la fonction check_player_guess ne nous permet pas de vérifié qu'une lettre apparaissant plusieurs fois a déjà été verifiée 
(en prenant en compte le nombre de fois où elle apparait dans le mot à deviner) ce qui fausse légèrement les indices apporté par self.review. """

#Jeu dans une classe pour la réutilisabilité et la capacité à être stocké (dans un dictionnaire par exemple, comme plus bas)
class GameOf5:
  def __init__(self, player, words):
    self.game_on = True
    self.turns = 6
    self.words = words
    self.words_left = len(self.words)
    self.word = self.words[self.words_left - 1]
    self.review = ""
    self.player = player
    print(f"{player} joue actuellement.")

  #méthodes get
  def get_word(self):
    return self.word

  def get_review(self):
    return self.review

  def get_turns(self):
    return self.turns

  #fonction mettant à jour les variables nécessaires au fonctionnement du jeu
  def reset_game(self, current_word):
    self.words.remove(current_word)
    self.words_left -= 1
    self.turns = 6
    print(self.words)

  def check_player_guess(self, guess):
    current_word = self.words[self.words_left -1]
    print(current_word)
    print(guess)
    bot_output = ""
    #le bot réecris le guess en émoji discord
    for char in guess:
      bot_output += f":regional_indicator_{char}: "
    bot_output += "\n"

    #le bot met en place les émojies d'indice en comparant le mot et l'essai
    for i in range(len(guess)):
      if guess[i] == current_word[i]:
        bot_output += f":green_circle: "
      elif guess[i] in current_word:
        bot_output += ":yellow_square: "
      else:
        bot_output += ":red_circle: "
    bot_output += "\n"

    self.review += bot_output
    used_turns = 6 - self.turns
    self.turns -= 1
    reveal = current_word
    if guess == current_word:
      self.reset_game(current_word)
      return (+10, f"Bravo. Victoire en {used_turns} essaies.\nIl te reste {self.words_left} mot(s). Tes points sont mis à jour.")
    elif self.turns == 0:
      self.reset_game(current_word)
      return (-10, f"Dommage, le mot était {reveal}. Il te reste {self.words_left} mot(s) à trouver. Tes points sont mis à jour.")
    else:
      print(self.get_review())
      return (0, f"Encore {self.turns} essaie(s).")
    self.review = ""

#Essentiellement la même classe que GameOf5 mais qui ne gère qu'un mot (word: string) et non une liste de mots 
class GameOf1:
  def __init__(self, player, word):
    self.game_on = True
    self.turns = 6
    self.word = word
    self.review = ""
    self.player = player
    print(f"{player} joue actuellement.")

  def get_word(self):
    return self.word

  def get_review(self):
    return self.review

  def get_turns(self):
    return self.turns

  def check_player_guess(self, guess):
    """if len(self.words) == 0:
      return False"""
    current_word = self.word
    print(current_word)
    print(guess)
    bot_output = ""
    for char in guess:
      bot_output += f":regional_indicator_{char}: "
    bot_output += "\n"

    for i in range(len(guess)):
      if guess[i] == current_word[i]:
        bot_output += f":green_circle: "
      elif guess[i] in current_word:
        bot_output += ":yellow_square: "
      else:
        bot_output += ":red_circle: "
    bot_output += "\n"

    self.review += bot_output
    used_turns = 6 - self.turns
    self.turns -= 1
    reveal = current_word
    if guess == current_word:
      self.game_on = False
      return (f"Bravo. Victoire en {used_turns} essaies.\n")
    elif self.turns == 0:
      self.game_on = False
      return (f"Dommage, le mot était {reveal}.")
    else:
      print(self.get_review())
      return (f"Encore {self.turns} essaie(s).")
    self.review = ""

import discord
import asyncio
import random
from datetime import date #check de la date pour GameOf1
from discord.ui import Select, View #menu déroulant
from discord.ext import commands
intents = discord.Intents.all()
intents.messages = True
intents.members = True
intents.typing = True
client = commands.Bot(command_prefix = "!", intents=intents)

#variables nécessaires : stockage des parties actuelles, repertoire des points, dictionnaire des thèmes (clés) et leurs listes de mot associés (valeurs).
currently_playing = {}
global_points = {}
playing_solo = {}

sports_words = ["basket", "tennis", "hockey", "volley", "karate", "soccer", "skater", "squash", "equipe", "course"]
cinema_words = ["avatar", "action", "genres", "scene", "ecrans", "acteur", "effets", "camera"]
mix_words = ["arbre", "bouger","danser", "ecrire", "futile", "gouter", "habile", "imagee", "jouant", "mature", "nourri", "ouvrir", "placer", "quitte", "rouler", "souple", "tendre", "usager", "virees","xenons","zozote", "aboyer", "boucle","eludes", "edifie", "effets","effile","effort", "effroi","emotif","budget","purger","cierge","cingle","clerge","cligne","cogite","cogner","poseur","posiez","postes"]
word_dict = {"sport": sports_words, "cinema": cinema_words, "mix": mix_words}


#fonction appelée lorsqu'un jour lance !play1 (today et daily_words deviennent GLOBAL dans la fonction), vérifie si la date à changé et retourne un nouveau mot si oui 
today = "2022-12-03"
def reset_daily_word(check_day, today):
  if today == check_day:
    return
  else :
    today = check_day
    daily_words = random.choice(mix_words)
    playing_solo = []
  print(today, daily_words)
  return today, daily_words

#fonction pour valider l'essaie du joueur, rend un bool
async def validate_guess(ctx, guess, word):
  if " " in guess:
    msg = f"Ton essaie est invalide, le mot ne doit pas contenir d'espace."
    await ctx.reply(msg)
    return False
  elif len(word) != len(guess):
    msg = f"Ton essaie est invalide, le mot ne doit contenir {len(word)} lettres/"
    await ctx.reply(msg)
    return False
  else:
    await ctx.reply(f"Vérifions pour {guess} :thinking:")
  return True

@client.event
async def on_ready():
  print(f"{client.user} est prêt.")

#affiche les règles 
@client.command()
async def rules(ctx):
   player = ctx.author
   await ctx.reply(f"*!play5* lance une partie de 5 mots, utilise *!dico* _tonmot_ pour jouer et *!end* pour quitter/mettre fin à ta partie.\n*!play1* lance une partie d'un mot en message privée, utilise *!solo* _tonmot_ pour jouer.\nAccède à ton score avec *!board*.")



#commande lancement de partie, avec choix du thème en menu déroulant  puis annonce des règles
@client.command()
async def play5(ctx):
  player = ctx.author
  #condition verifiant que le joueur ne joue pas déjà
  if player in currently_playing:
    await ctx.reply(f"Tu es déjà dans une partie.")
    return
  else:
    select = Select(options=[
        discord.SelectOption(label="sport"),
        discord.SelectOption(label="cinema"),
        discord.SelectOption(label="mix")
    ])

    #actions lorsque le joueur choisit un thème dans le menu
    async def my_callback(interaction):
      await interaction.response.send_message(f"Tu as choisis le thème : {select.values[0]}.")
      #création et  stockage de la partie
      currently_playing[player] = GameOf5(player, list(random.sample(word_dict[select.values[0]], 5)))
      #création du profil du joueur dans le classement
      if player in global_points:
        return
      else:
        global_points[player] = 0
      #annonce
      await ctx.reply(f"Une partie {select.values[0]} s'est crée pour {player}.\nUtilise !dico pour deviner en 6 essaies les mots à {len(currently_playing[player].get_word())} lettres.")
      print(f"Partie crée pour {player}, {currently_playing[player]}")

    select.callback = my_callback
    view = View()
    view.add_item(select)
    await ctx.send(f"{player.name} doit choisir un thème.", view=view)

@client.command()
async def dico(ctx, guess):
  player = ctx.author
  if not ctx.author in currently_playing:
    await ctx.reply(f"Tu n'as pas lancé de partie.")
    return
  else:
    if not await validate_guess(ctx, guess, currently_playing[player].get_word()):
      return
    (game_result, announce) = currently_playing[player].check_player_guess(guess.lower())
    global_points[player] += game_result
    print(global_points[player])
    await ctx.send(currently_playing[player].get_review())
    await ctx.send(announce)
    if game_result != 0:
      currently_playing[player].review = ""

@client.command()
async def play1(ctx):
  player = ctx.author
  global today, daily_words
  (today, daily_words) = reset_daily_word(date.today() ,today)
  if player in playing_solo :
    await ctx.reply("Vous avez déjà fait le mot du jour")
    return
  else :
    playing_solo[player] = GameOf1(player, daily_words)
    await ctx.author.send(f"La partie de {player} commence")    


@client.command()
async def solo(ctx, guess):
  player = ctx.author
  if not ctx.author in playing_solo:
    await ctx.reply(f"Tu n'as pas lancé de partie.")
    return
  else: 
    if playing_solo[player].game_on == True:
      if not await validate_guess(ctx, guess, daily_words):
        return
      announce = playing_solo[player].check_player_guess(guess.lower())
      await ctx.send(playing_solo[player].get_review())
      await ctx.send(announce)
    else:
      await ctx.reply("La partie est terminée.")
    
#ajouter condition de fin de partie ou une méthode pour quitter tout court
@client.command()
async def end(ctx):
  player= ctx.author
  if not player in currently_playing:
    await ctx.reply("Tu n'es pas en jeu.")
    return
  else:
    currently_playing.pop(player)
    await ctx.reply(f"La partie de {player} à été supprimée.")
    
#commande de classement global (points)
@client.command()
async def board(ctx):
  player = ctx.author
  if not player in global_points:
    await ctx.reply ("Tu n'es pas classé")
    return
  else:
    await ctx.reply (f"Tu as {global_points.get(player)} points ")


client.run("MTA0NDg5OTMxOTQ5NDQ3NTc4Nw.Gk52XP.pJ3BqFCuyhGXJDol5DiHWoZASispPqN3eXq-Zo")